//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: third_party/nucleus/vendor/python/statusor_examples.clif

#include <Python.h>
#include "absl/memory/memory.h"
#include "absl/types/optional.h"
#include "clif/python/types.h"
#include "third_party/nucleus/vendor/statusor_clif_converters.h"
#include "statusor_examples.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace third__party_nucleus_vendor_python_statusor__examples_clifwrap {

using namespace clif;

static const char* ThisModuleName = "third_party.nucleus.vendor.python.statusor_examples";

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

// MakeIntOK() -> StatusOr<int>
static PyObject* wrapMakeIntOK(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr<int> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeIntOK();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// MakeIntFail() -> StatusOr<int>
static PyObject* wrapMakeIntFail(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr<int> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeIntFail();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// MakeStrOK() -> StatusOr<str>
static PyObject* wrapMakeStrOK(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::string> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeStrOK();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {_1});
}

// MakeStrFail() -> StatusOr<str>
static PyObject* wrapMakeStrFail(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::string> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeStrFail();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {_1});
}

// MakeIntUniquePtrOK() -> StatusOr<int>
static PyObject* wrapMakeIntUniquePtrOK(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr<int>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeIntUniquePtrOK();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// MakeIntUniquePtrFail() -> StatusOr<int>
static PyObject* wrapMakeIntUniquePtrFail(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr<int>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeIntUniquePtrFail();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// MakeIntVectorOK() -> StatusOr<list<int>>
static PyObject* wrapMakeIntVectorOK(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr< ::std::vector<int>>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeIntVectorOK();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// MakeIntVectorFail() -> StatusOr<list<int>>
static PyObject* wrapMakeIntVectorFail(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr< ::std::vector<int>>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::MakeIntVectorFail();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// FuncReturningStatusOK() -> Status
static PyObject* wrapFuncReturningStatusOK(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::FuncReturningStatusOK();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// FuncReturningStatusFail() -> Status
static PyObject* wrapFuncReturningStatusFail(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::FuncReturningStatusFail();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Initialize module

static PyMethodDef MethodsStaticAlloc[] = {
  {"MakeIntOK", (PyCFunction)wrapMakeIntOK, METH_NOARGS, "MakeIntOK() -> StatusOr<int>\n  Calls C++ function\n  ::nucleus::StatusOr<int> ::nucleus::MakeIntOK()"},
  {"MakeIntFail", (PyCFunction)wrapMakeIntFail, METH_NOARGS, "MakeIntFail() -> StatusOr<int>\n  Calls C++ function\n  ::nucleus::StatusOr<int> ::nucleus::MakeIntFail()"},
  {"MakeStrOK", (PyCFunction)wrapMakeStrOK, METH_NOARGS, "MakeStrOK() -> StatusOr<str>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::string> ::nucleus::MakeStrOK()"},
  {"MakeStrFail", (PyCFunction)wrapMakeStrFail, METH_NOARGS, "MakeStrFail() -> StatusOr<str>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::string> ::nucleus::MakeStrFail()"},
  {"MakeIntUniquePtrOK", (PyCFunction)wrapMakeIntUniquePtrOK, METH_NOARGS, "MakeIntUniquePtrOK() -> StatusOr<int>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr<int>> ::nucleus::MakeIntUniquePtrOK()"},
  {"MakeIntUniquePtrFail", (PyCFunction)wrapMakeIntUniquePtrFail, METH_NOARGS, "MakeIntUniquePtrFail() -> StatusOr<int>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr<int>> ::nucleus::MakeIntUniquePtrFail()"},
  {"MakeIntVectorOK", (PyCFunction)wrapMakeIntVectorOK, METH_NOARGS, "MakeIntVectorOK() -> StatusOr<list<int>>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr< ::std::vector<int>>> ::nucleus::MakeIntVectorOK()"},
  {"MakeIntVectorFail", (PyCFunction)wrapMakeIntVectorFail, METH_NOARGS, "MakeIntVectorFail() -> StatusOr<list<int>>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr< ::std::vector<int>>> ::nucleus::MakeIntVectorFail()"},
  {"FuncReturningStatusOK", (PyCFunction)wrapFuncReturningStatusOK, METH_NOARGS, "FuncReturningStatusOK() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::FuncReturningStatusOK()"},
  {"FuncReturningStatusFail", (PyCFunction)wrapFuncReturningStatusFail, METH_NOARGS, "FuncReturningStatusFail() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::FuncReturningStatusFail()"},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  ThisModuleName,
  "CLIF-generated module for third_party/nucleus/vendor/python/statusor_examples.clif", // module doc
  -1,  // module keeps state in global variables
  MethodsStaticAlloc,
  nullptr,  // m_slots a.k.a. m_reload
  nullptr,  // m_traverse
  ClearImportCache  // m_clear
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  return module;
}

}  // namespace third__party_nucleus_vendor_python_statusor__examples_clifwrap
