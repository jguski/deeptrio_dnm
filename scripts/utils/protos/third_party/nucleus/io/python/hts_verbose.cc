//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: third_party/nucleus/io/python/hts_verbose.clif

#include <Python.h>
#include "absl/memory/memory.h"
#include "absl/types/optional.h"
#include "clif/python/types.h"
#include "hts_verbose.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace third__party_nucleus_io_python_hts__verbose_clifwrap {

using namespace clif;

static const char* ThisModuleName = "third_party.nucleus.io.python.hts_verbose";

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()

// Create Python Enum object (cached in _htsLogLevel) for ::htsLogLevel
static PyObject* wraphtsLogLevel() {
  PyObject *py_enum_class = nullptr;
  PyObject *modname = nullptr;
  PyObject *py = nullptr;
  PyObject *names = PyTuple_New(6);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("HTS_LOG_DEBUG"), PyLong_FromLong(
        static_cast<typename std::underlying_type<::htsLogLevel>::type>(::HTS_LOG_DEBUG)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("HTS_LOG_ERROR"), PyLong_FromLong(
        static_cast<typename std::underlying_type<::htsLogLevel>::type>(::HTS_LOG_ERROR)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("HTS_LOG_INFO"), PyLong_FromLong(
        static_cast<typename std::underlying_type<::htsLogLevel>::type>(::HTS_LOG_INFO)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("HTS_LOG_OFF"), PyLong_FromLong(
        static_cast<typename std::underlying_type<::htsLogLevel>::type>(::HTS_LOG_OFF)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("HTS_LOG_TRACE"), PyLong_FromLong(
        static_cast<typename std::underlying_type<::htsLogLevel>::type>(::HTS_LOG_TRACE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("HTS_LOG_WARNING"), PyLong_FromLong(
        static_cast<typename std::underlying_type<::htsLogLevel>::type>(::HTS_LOG_WARNING)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 5, py);
  py = PyUnicode_FromString("htsLogLevel");
  if (py == nullptr) {
    goto err;
  }
  modname = PyUnicode_FromString(ThisModuleName);
  if (modname == nullptr) {
    goto err;
  }
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  if (py_enum_class != nullptr) {
    PyObject_SetAttrString(py_enum_class, "__module__", modname);
  }
err:
  Py_XDECREF(modname);
  Py_XDECREF(py);
  Py_XDECREF(names);
  return py_enum_class;
}

static PyObject* _htsLogLevel{};  // set by above func in Init()

// get() -> htsLogLevel
static PyObject* wrapHtsGetLogLevel_as_get(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::htsLogLevel ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::HtsGetLogLevel();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set(level:htsLogLevel)
static PyObject* wrapHtsSetLogLevel_as_set(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  const char* names[] = {
      "level",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set", const_cast<char**>(names), &a[0])) return nullptr;
  ::htsLogLevel arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set", names[0], "::htsLogLevel", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ::nucleus::HtsSetLogLevel(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Initialize module

static PyMethodDef MethodsStaticAlloc[] = {
  {"get", (PyCFunction)wrapHtsGetLogLevel_as_get, METH_NOARGS, "get() -> htsLogLevel\n  Calls C++ function\n  ::htsLogLevel ::nucleus::HtsGetLogLevel()"},
  {"set", (PyCFunction)wrapHtsSetLogLevel_as_set, METH_VARARGS | METH_KEYWORDS, "set(level:htsLogLevel)\n  Calls C++ function\n  void ::nucleus::HtsSetLogLevel(::htsLogLevel)"},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  ThisModuleName,
  "CLIF-generated module for third_party/nucleus/io/python/hts_verbose.clif", // module doc
  -1,  // module keeps state in global variables
  MethodsStaticAlloc,
  nullptr,  // m_slots a.k.a. m_reload
  nullptr,  // m_traverse
  ClearImportCache  // m_clear
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyModule_AddObject(module, "htsLogLevel", (_htsLogLevel=wraphtsLogLevel())) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace third__party_nucleus_io_python_hts__verbose_clifwrap

namespace clif {

// htsLogLevel:IntEnum to/from enum ::htsLogLevel conversion

bool Clif_PyObjAs(PyObject* py, ::htsLogLevel* c) {
  CHECK(c != nullptr);
  if (!PyObject_IsInstance(py, third__party_nucleus_io_python_hts__verbose_clifwrap::_htsLogLevel)) {
    PyErr_Format(PyExc_TypeError, "expecting enum htsLogLevel, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::htsLogLevel>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::htsLogLevel>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::htsLogLevel& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(third__party_nucleus_io_python_hts__verbose_clifwrap::_htsLogLevel, PyLong_FromLong(
      static_cast<typename std::underlying_type<::htsLogLevel>::type>(c)), nullptr);
}

}  // namespace clif
