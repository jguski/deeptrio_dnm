//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: third_party/nucleus/io/python/reference.clif

#include <Python.h>
#include "absl/memory/memory.h"
#include "absl/types/optional.h"
#include "clif/python/types.h"
#include "third_party/nucleus/protos/fasta_pyclif.h"
#include "third_party/nucleus/protos/range_pyclif.h"
#include "third_party/nucleus/protos/reference_pyclif.h"
#include "third_party/nucleus/vendor/statusor_clif_converters.h"
#include "reference.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace third__party_nucleus_io_python_reference_clifwrap {

using namespace clif;

static const char* ThisModuleName = "third_party.nucleus.io.python.reference";

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

namespace pyGenomeReferenceRecordIterable {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>> cpp;
  PyObject* instance_dict = nullptr;
  PyObject* weakrefs = nullptr;
};

static ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* ThisPtr(PyObject*);

// Next() -> (not_done:StatusOr<bool>, fasta:tuple<str, str>)
static PyObject* wrapNext(PyObject* self) {
  std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>> ret1{};
  // Call actual C++ method.
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr<bool> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->Next(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {_1,_1})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// Release() -> Status
static PyObject* wrapRelease(PyObject* self) {
  // Call actual C++ method.
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->Release();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __enter__@() -> Status
static PyObject* wrapPythonEnter_as___enter__(PyObject* self) {
  // Call actual C++ method.
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->PythonEnter();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_INCREF(self);
  return self;
}

// __exit__@() -> Status
static PyObject* wrapPythonExit_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->PythonExit();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

// Implicit cast this as ::nucleus::IterableBase*
static PyObject* as_nucleus_IterableBase(PyObject* self) {
  ::nucleus::IterableBase* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::IterableBase", nullptr);
}

static PyMethodDef MethodsStaticAlloc[] = {
  {"Next", (PyCFunction)wrapNext, METH_NOARGS, "Next() -> (not_done:StatusOr<bool>, fasta:tuple<str, str>)\n  Calls C++ function\n  ::nucleus::StatusOr<bool> ::nucleus::Iterable<std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>>>::Next(std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>*)"},
  {"Release", (PyCFunction)wrapRelease, METH_NOARGS, "Release() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::IterableBase::Release()"},
  {"__enter__", (PyCFunction)wrapPythonEnter_as___enter__, METH_NOARGS, "__enter__@() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::IterableBase::PythonEnter()"},
  {"__exit__", (PyCFunction)wrapPythonExit_as___exit__, METH_VARARGS | METH_KEYWORDS, "__exit__@() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::IterableBase::PythonExit()"},
  {"as_nucleus_IterableBase", (PyCFunction)as_nucleus_IterableBase, METH_NOARGS, "Upcast to ::nucleus::IterableBase*"},
  {"__reduce_ex__", (PyCFunction)::clif::ReduceExImpl, METH_VARARGS | METH_KEYWORDS, "Helper for pickle."},
  {}
};

// GenomeReferenceRecordIterable __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// GenomeReferenceRecordIterable __del__
static void _dtor(PyObject* self) {
  if (reinterpret_cast<wrapper*>(self)->weakrefs) {
    PyObject_ClearWeakRefs(self);
  }
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}

static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject* wrapper_Type = nullptr;

static PyTypeObject* _build_heap_type() {
  PyHeapTypeObject *heap_type =
      (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
  if (!heap_type)
    return nullptr;
  heap_type->ht_qualname = (PyObject *) PyUnicode_FromString(
      "GenomeReferenceRecordIterable");
  Py_INCREF(heap_type->ht_qualname);
  heap_type->ht_name = heap_type->ht_qualname;
  PyTypeObject *ty = &heap_type->ht_type;
  ty->tp_as_number = &heap_type->as_number;
  ty->tp_as_sequence = &heap_type->as_sequence;
  ty->tp_as_mapping = &heap_type->as_mapping;
#if PY_VERSION_HEX >= 0x03050000
  ty->tp_as_async = &heap_type->as_async;
#endif
  ty->tp_name = "third_party.nucleus.io.python.reference.GenomeReferenceRecordIterable";
  ty->tp_basicsize = sizeof(wrapper);
  ty->tp_dealloc = _dtor;
  ty->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
  ty->tp_doc = "CLIF wrapper for ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>";
  ty->tp_methods = MethodsStaticAlloc;
  ty->tp_init = Clif_PyType_Inconstructible;
  ty->tp_alloc = _new;
  ty->tp_new = PyType_GenericNew;
  ty->tp_free = _del;
  ty->tp_weaklistoffset = offsetof(wrapper, weakrefs);
  return ty;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  DCHECK(nitems == 0);
  wrapper* wobj = new wrapper;
  PyObject* self = reinterpret_cast<PyObject*>(wobj);
  return PyObject_Init(self, wrapper_Type);
}

static ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, "as_nucleus_Iterable_std_pair__std_basic_string_char__std_char_traits_char___std_allocator_char____std_basic_string_char__std_char_traits_char___std_allocator_char", nullptr);
  if (base == nullptr) {
    PyErr_Clear();
  } else {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, "::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>");
      if (!PyErr_Occurred()) {
        ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* c = static_cast<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(wrapper_Type))) {
    if (!base) {
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type->tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}

}  // namespace pyGenomeReferenceRecordIterable

namespace pyGenomeReference {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::nucleus::GenomeReference> cpp;
  PyObject* instance_dict = nullptr;
  PyObject* weakrefs = nullptr;
};

static ::nucleus::GenomeReference* ThisPtr(PyObject*);

static PyObject* get_contig_names(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ContigNames(), {_1});
}

// contig(chrom:str) -> StatusOr<ContigInfo>
static PyObject* wrapContig_as_contig(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  const char* names[] = {
      "chrom",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:contig", const_cast<char**>(names), &a[0])) return nullptr;
  ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("contig", names[0], "::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>", a[0]);
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr<const ::nucleus::genomics::v1::ContigInfo *> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->Contig(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// bases(region:Range) -> StatusOr<str>
static PyObject* wrapGetBases_as_bases(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  const char* names[] = {
      "region",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:bases", const_cast<char**>(names), &a[0])) return nullptr;
  ::nucleus::genomics::v1::Range arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("bases", names[0], "::nucleus::genomics::v1::Range", a[0]);
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::string> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->GetBases(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {_1});
}

// iterate() -> StatusOr<GenomeReferenceRecordIterable>
static PyObject* wrapIterate_as_iterate(PyObject* self) {
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::shared_ptr< ::nucleus::GenomeReferenceRecordIterable>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->Iterate();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("third_party.nucleus.io.clif_postproc.WrappedReferenceIterable");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// has_contig(contig_name:str) -> bool
static PyObject* wrapHasContig_as_has_contig(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  const char* names[] = {
      "contig_name",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_contig", const_cast<char**>(names), &a[0])) return nullptr;
  ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_contig", names[0], "::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>", a[0]);
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->HasContig(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_valid_interval(region:Range) -> bool
static PyObject* wrapIsValidInterval_as_is_valid_interval(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  const char* names[] = {
      "region",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:is_valid_interval", const_cast<char**>(names), &a[0])) return nullptr;
  ::nucleus::genomics::v1::Range arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_valid_interval", names[0], "::nucleus::genomics::v1::Range", a[0]);
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->IsValidInterval(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_contigs(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Contigs(), {});
}

// __enter__@() -> Status
static PyObject* wrapPythonEnter_as___enter__(PyObject* self) {
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->PythonEnter();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_INCREF(self);
  return self;
}

// __exit__@() -> Status
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::nucleus::GenomeReference* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::tensorflow::Status ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {"contig_names", get_contig_names, nullptr, "C++ clif_type_11 GenomeReference.ContigNames()"},
  {"contigs", get_contigs, nullptr, "C++ clif_type_27 GenomeReference.Contigs()"},
  {}
};

// Implicit cast this as ::nucleus::Reader*
static PyObject* as_nucleus_Reader(PyObject* self) {
  ::nucleus::Reader* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::Reader", nullptr);
}

static PyMethodDef MethodsStaticAlloc[] = {
  {"contig", (PyCFunction)wrapContig_as_contig, METH_VARARGS | METH_KEYWORDS, "contig(chrom:str) -> StatusOr<ContigInfo>\n  Calls C++ function\n  ::nucleus::StatusOr<const ::nucleus::genomics::v1::ContigInfo *> ::nucleus::GenomeReference::Contig(::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>)"},
  {"bases", (PyCFunction)wrapGetBases_as_bases, METH_VARARGS | METH_KEYWORDS, "bases(region:Range) -> StatusOr<str>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::string> ::nucleus::GenomeReference::GetBases(::nucleus::genomics::v1::Range)"},
  {"iterate", (PyCFunction)wrapIterate_as_iterate, METH_NOARGS, "iterate() -> StatusOr<GenomeReferenceRecordIterable>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::shared_ptr< ::nucleus::GenomeReferenceRecordIterable>> ::nucleus::GenomeReference::Iterate()"},
  {"has_contig", (PyCFunction)wrapHasContig_as_has_contig, METH_VARARGS | METH_KEYWORDS, "has_contig(contig_name:str) -> bool\n  Calls C++ function\n  bool ::nucleus::GenomeReference::HasContig(::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>)"},
  {"is_valid_interval", (PyCFunction)wrapIsValidInterval_as_is_valid_interval, METH_VARARGS | METH_KEYWORDS, "is_valid_interval(region:Range) -> bool\n  Calls C++ function\n  bool ::nucleus::GenomeReference::IsValidInterval(::nucleus::genomics::v1::Range)"},
  {"__enter__", (PyCFunction)wrapPythonEnter_as___enter__, METH_NOARGS, "__enter__@() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::GenomeReference::PythonEnter()"},
  {"__exit__", (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, "__exit__@() -> Status\n  Calls C++ function\n  ::tensorflow::Status ::nucleus::GenomeReference::Close()"},
  {"as_nucleus_Reader", (PyCFunction)as_nucleus_Reader, METH_NOARGS, "Upcast to ::nucleus::Reader*"},
  {"__reduce_ex__", (PyCFunction)::clif::ReduceExImpl, METH_VARARGS | METH_KEYWORDS, "Helper for pickle."},
  {}
};

// GenomeReference __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// GenomeReference __del__
static void _dtor(PyObject* self) {
  if (reinterpret_cast<wrapper*>(self)->weakrefs) {
    PyObject_ClearWeakRefs(self);
  }
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}

static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject* wrapper_Type = nullptr;

static PyTypeObject* _build_heap_type() {
  PyHeapTypeObject *heap_type =
      (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
  if (!heap_type)
    return nullptr;
  heap_type->ht_qualname = (PyObject *) PyUnicode_FromString(
      "GenomeReference");
  Py_INCREF(heap_type->ht_qualname);
  heap_type->ht_name = heap_type->ht_qualname;
  PyTypeObject *ty = &heap_type->ht_type;
  ty->tp_as_number = &heap_type->as_number;
  ty->tp_as_sequence = &heap_type->as_sequence;
  ty->tp_as_mapping = &heap_type->as_mapping;
#if PY_VERSION_HEX >= 0x03050000
  ty->tp_as_async = &heap_type->as_async;
#endif
  ty->tp_name = "third_party.nucleus.io.python.reference.GenomeReference";
  ty->tp_basicsize = sizeof(wrapper);
  ty->tp_dealloc = _dtor;
  ty->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
  ty->tp_doc = "CLIF wrapper for ::nucleus::GenomeReference";
  ty->tp_methods = MethodsStaticAlloc;
  ty->tp_getset = Properties;
  ty->tp_init = Clif_PyType_Inconstructible;
  ty->tp_alloc = _new;
  ty->tp_new = PyType_GenericNew;
  ty->tp_free = _del;
  ty->tp_weaklistoffset = offsetof(wrapper, weakrefs);
  return ty;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  DCHECK(nitems == 0);
  wrapper* wobj = new wrapper;
  PyObject* self = reinterpret_cast<PyObject*>(wobj);
  return PyObject_Init(self, wrapper_Type);
}

static ::nucleus::GenomeReference* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, "as_nucleus_GenomeReference", nullptr);
  if (base == nullptr) {
    PyErr_Clear();
  } else {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, "::nucleus::GenomeReference");
      if (!PyErr_Occurred()) {
        ::nucleus::GenomeReference* c = static_cast<::nucleus::GenomeReference*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(wrapper_Type))) {
    if (!base) {
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::nucleus::GenomeReference*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type->tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}

}  // namespace pyGenomeReference

namespace pyIndexedFastaReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::nucleus::IndexedFastaReader> cpp;
  PyObject* instance_dict = nullptr;
  PyObject* weakrefs = nullptr;
};

static ::nucleus::IndexedFastaReader* ThisPtr(PyObject*);

// @classmethod from_file(fasta_path:str, fai_path:str, options:FastaReaderOptions, cache_size_bases:int=default) -> StatusOr<IndexedFastaReader>
static PyObject* wrapFromFile_as_from_file(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  const char* names[] = {
      "fasta_path",
      "fai_path",
      "options",
      "cache_size_bases",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:from_file", const_cast<char**>(names), &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_file", names[0], "::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>", a[0]);
  ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_file", names[1], "::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>", a[1]);
  ::nucleus::genomics::v1::FastaReaderOptions arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_file", names[2], "::nucleus::genomics::v1::FastaReaderOptions", a[2]);
  int arg4;
  if (nargs > 3) {
    if (!a[3]) arg4 = (int)65536;
    else if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_file", names[3], "int", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr< ::nucleus::IndexedFastaReader>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ret0 = ::nucleus::IndexedFastaReader::FromFile(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    ret0 = ::nucleus::IndexedFastaReader::FromFile(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::nucleus::GenomeReference*
static PyObject* as_nucleus_GenomeReference(PyObject* self) {
  ::nucleus::GenomeReference* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::GenomeReference", nullptr);
}

// Implicit cast this as ::nucleus::Reader*
static PyObject* as_nucleus_Reader(PyObject* self) {
  ::nucleus::Reader* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::Reader", nullptr);
}

static PyMethodDef MethodsStaticAlloc[] = {
  {"from_file", (PyCFunction)wrapFromFile_as_from_file, METH_VARARGS | METH_KEYWORDS | METH_CLASS, "from_file(fasta_path:str, fai_path:str, options:FastaReaderOptions, cache_size_bases:int=default) -> StatusOr<IndexedFastaReader>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr< ::nucleus::IndexedFastaReader>> ::nucleus::IndexedFastaReader::FromFile(::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::nucleus::genomics::v1::FastaReaderOptions, int)"},
  {"as_nucleus_GenomeReference", (PyCFunction)as_nucleus_GenomeReference, METH_NOARGS, "Upcast to ::nucleus::GenomeReference*"},
  {"as_nucleus_Reader", (PyCFunction)as_nucleus_Reader, METH_NOARGS, "Upcast to ::nucleus::Reader*"},
  {"__reduce_ex__", (PyCFunction)::clif::ReduceExImpl, METH_VARARGS | METH_KEYWORDS, "Helper for pickle."},
  {}
};

// IndexedFastaReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IndexedFastaReader __del__
static void _dtor(PyObject* self) {
  if (reinterpret_cast<wrapper*>(self)->weakrefs) {
    PyObject_ClearWeakRefs(self);
  }
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}

static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject* wrapper_Type = nullptr;

static PyTypeObject* _build_heap_type() {
  PyHeapTypeObject *heap_type =
      (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
  if (!heap_type)
    return nullptr;
  heap_type->ht_qualname = (PyObject *) PyUnicode_FromString(
      "IndexedFastaReader");
  Py_INCREF(heap_type->ht_qualname);
  heap_type->ht_name = heap_type->ht_qualname;
  PyTypeObject *ty = &heap_type->ht_type;
  ty->tp_as_number = &heap_type->as_number;
  ty->tp_as_sequence = &heap_type->as_sequence;
  ty->tp_as_mapping = &heap_type->as_mapping;
#if PY_VERSION_HEX >= 0x03050000
  ty->tp_as_async = &heap_type->as_async;
#endif
  ty->tp_name = "third_party.nucleus.io.python.reference.IndexedFastaReader";
  ty->tp_basicsize = sizeof(wrapper);
  ty->tp_dealloc = _dtor;
  ty->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
  ty->tp_doc = "CLIF wrapper for ::nucleus::IndexedFastaReader";
  ty->tp_methods = MethodsStaticAlloc;
  ty->tp_init = Clif_PyType_Inconstructible;
  ty->tp_alloc = _new;
  ty->tp_new = PyType_GenericNew;
  ty->tp_free = _del;
  ty->tp_weaklistoffset = offsetof(wrapper, weakrefs);
  return ty;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  DCHECK(nitems == 0);
  wrapper* wobj = new wrapper;
  PyObject* self = reinterpret_cast<PyObject*>(wobj);
  return PyObject_Init(self, wrapper_Type);
}

static ::nucleus::IndexedFastaReader* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, "as_nucleus_IndexedFastaReader", nullptr);
  if (base == nullptr) {
    PyErr_Clear();
  } else {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, "::nucleus::IndexedFastaReader");
      if (!PyErr_Occurred()) {
        ::nucleus::IndexedFastaReader* c = static_cast<::nucleus::IndexedFastaReader*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(wrapper_Type))) {
    if (!base) {
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::nucleus::IndexedFastaReader*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type->tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}

}  // namespace pyIndexedFastaReader

namespace pyUnindexedFastaReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::nucleus::UnindexedFastaReader> cpp;
  PyObject* instance_dict = nullptr;
  PyObject* weakrefs = nullptr;
};

static ::nucleus::UnindexedFastaReader* ThisPtr(PyObject*);

// @classmethod from_file(fasta_path:str) -> StatusOr<UnindexedFastaReader>
static PyObject* wrapFromFile_as_from_file(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  const char* names[] = {
      "fasta_path",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_file", const_cast<char**>(names), &a[0])) return nullptr;
  ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_file", names[0], "::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr< ::nucleus::UnindexedFastaReader>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::UnindexedFastaReader::FromFile(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::nucleus::GenomeReference*
static PyObject* as_nucleus_GenomeReference(PyObject* self) {
  ::nucleus::GenomeReference* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::GenomeReference", nullptr);
}

// Implicit cast this as ::nucleus::Reader*
static PyObject* as_nucleus_Reader(PyObject* self) {
  ::nucleus::Reader* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::Reader", nullptr);
}

static PyMethodDef MethodsStaticAlloc[] = {
  {"from_file", (PyCFunction)wrapFromFile_as_from_file, METH_VARARGS | METH_KEYWORDS | METH_CLASS, "from_file(fasta_path:str) -> StatusOr<UnindexedFastaReader>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr< ::nucleus::UnindexedFastaReader>> ::nucleus::UnindexedFastaReader::FromFile(::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>)"},
  {"as_nucleus_GenomeReference", (PyCFunction)as_nucleus_GenomeReference, METH_NOARGS, "Upcast to ::nucleus::GenomeReference*"},
  {"as_nucleus_Reader", (PyCFunction)as_nucleus_Reader, METH_NOARGS, "Upcast to ::nucleus::Reader*"},
  {"__reduce_ex__", (PyCFunction)::clif::ReduceExImpl, METH_VARARGS | METH_KEYWORDS, "Helper for pickle."},
  {}
};

// UnindexedFastaReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// UnindexedFastaReader __del__
static void _dtor(PyObject* self) {
  if (reinterpret_cast<wrapper*>(self)->weakrefs) {
    PyObject_ClearWeakRefs(self);
  }
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}

static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject* wrapper_Type = nullptr;

static PyTypeObject* _build_heap_type() {
  PyHeapTypeObject *heap_type =
      (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
  if (!heap_type)
    return nullptr;
  heap_type->ht_qualname = (PyObject *) PyUnicode_FromString(
      "UnindexedFastaReader");
  Py_INCREF(heap_type->ht_qualname);
  heap_type->ht_name = heap_type->ht_qualname;
  PyTypeObject *ty = &heap_type->ht_type;
  ty->tp_as_number = &heap_type->as_number;
  ty->tp_as_sequence = &heap_type->as_sequence;
  ty->tp_as_mapping = &heap_type->as_mapping;
#if PY_VERSION_HEX >= 0x03050000
  ty->tp_as_async = &heap_type->as_async;
#endif
  ty->tp_name = "third_party.nucleus.io.python.reference.UnindexedFastaReader";
  ty->tp_basicsize = sizeof(wrapper);
  ty->tp_dealloc = _dtor;
  ty->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
  ty->tp_doc = "CLIF wrapper for ::nucleus::UnindexedFastaReader";
  ty->tp_methods = MethodsStaticAlloc;
  ty->tp_init = Clif_PyType_Inconstructible;
  ty->tp_alloc = _new;
  ty->tp_new = PyType_GenericNew;
  ty->tp_free = _del;
  ty->tp_weaklistoffset = offsetof(wrapper, weakrefs);
  return ty;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  DCHECK(nitems == 0);
  wrapper* wobj = new wrapper;
  PyObject* self = reinterpret_cast<PyObject*>(wobj);
  return PyObject_Init(self, wrapper_Type);
}

static ::nucleus::UnindexedFastaReader* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, "as_nucleus_UnindexedFastaReader", nullptr);
  if (base == nullptr) {
    PyErr_Clear();
  } else {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, "::nucleus::UnindexedFastaReader");
      if (!PyErr_Occurred()) {
        ::nucleus::UnindexedFastaReader* c = static_cast<::nucleus::UnindexedFastaReader*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(wrapper_Type))) {
    if (!base) {
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::nucleus::UnindexedFastaReader*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type->tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}

}  // namespace pyUnindexedFastaReader

namespace pyInMemoryFastaReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::nucleus::InMemoryFastaReader> cpp;
  PyObject* instance_dict = nullptr;
  PyObject* weakrefs = nullptr;
};

static ::nucleus::InMemoryFastaReader* ThisPtr(PyObject*);

// @classmethod create(contigs:list<ContigInfo>, seqs:list<ReferenceSequence>) -> StatusOr<InMemoryFastaReader>
static PyObject* wrapCreate_as_create(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  const char* names[] = {
      "contigs",
      "seqs",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:create", const_cast<char**>(names), &a[0], &a[1])) return nullptr;
  ::std::vector< ::nucleus::genomics::v1::ContigInfo> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("create", names[0], "::std::vector< ::nucleus::genomics::v1::ContigInfo>", a[0]);
  ::std::vector< ::nucleus::genomics::v1::ReferenceSequence> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("create", names[1], "::std::vector< ::nucleus::genomics::v1::ReferenceSequence>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::nucleus::StatusOr< ::std::unique_ptr< ::nucleus::InMemoryFastaReader>> ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::InMemoryFastaReader::Create(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_reference_sequences(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ReferenceSequences(), {_1,_0});
}

static PyGetSetDef Properties[] = {
  {"reference_sequences", get_reference_sequences, nullptr, "C++ clif_type_52 InMemoryFastaReader.ReferenceSequences()"},
  {}
};

// Implicit cast this as ::nucleus::GenomeReference*
static PyObject* as_nucleus_GenomeReference(PyObject* self) {
  ::nucleus::GenomeReference* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::GenomeReference", nullptr);
}

// Implicit cast this as ::nucleus::Reader*
static PyObject* as_nucleus_Reader(PyObject* self) {
  ::nucleus::Reader* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, "::nucleus::Reader", nullptr);
}

static PyMethodDef MethodsStaticAlloc[] = {
  {"create", (PyCFunction)wrapCreate_as_create, METH_VARARGS | METH_KEYWORDS | METH_CLASS, "create(contigs:list<ContigInfo>, seqs:list<ReferenceSequence>) -> StatusOr<InMemoryFastaReader>\n  Calls C++ function\n  ::nucleus::StatusOr< ::std::unique_ptr< ::nucleus::InMemoryFastaReader>> ::nucleus::InMemoryFastaReader::Create(::std::vector< ::nucleus::genomics::v1::ContigInfo>, ::std::vector< ::nucleus::genomics::v1::ReferenceSequence>)"},
  {"as_nucleus_GenomeReference", (PyCFunction)as_nucleus_GenomeReference, METH_NOARGS, "Upcast to ::nucleus::GenomeReference*"},
  {"as_nucleus_Reader", (PyCFunction)as_nucleus_Reader, METH_NOARGS, "Upcast to ::nucleus::Reader*"},
  {"__reduce_ex__", (PyCFunction)::clif::ReduceExImpl, METH_VARARGS | METH_KEYWORDS, "Helper for pickle."},
  {}
};

// InMemoryFastaReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// InMemoryFastaReader __del__
static void _dtor(PyObject* self) {
  if (reinterpret_cast<wrapper*>(self)->weakrefs) {
    PyObject_ClearWeakRefs(self);
  }
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}

static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject* wrapper_Type = nullptr;

static PyTypeObject* _build_heap_type() {
  PyHeapTypeObject *heap_type =
      (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
  if (!heap_type)
    return nullptr;
  heap_type->ht_qualname = (PyObject *) PyUnicode_FromString(
      "InMemoryFastaReader");
  Py_INCREF(heap_type->ht_qualname);
  heap_type->ht_name = heap_type->ht_qualname;
  PyTypeObject *ty = &heap_type->ht_type;
  ty->tp_as_number = &heap_type->as_number;
  ty->tp_as_sequence = &heap_type->as_sequence;
  ty->tp_as_mapping = &heap_type->as_mapping;
#if PY_VERSION_HEX >= 0x03050000
  ty->tp_as_async = &heap_type->as_async;
#endif
  ty->tp_name = "third_party.nucleus.io.python.reference.InMemoryFastaReader";
  ty->tp_basicsize = sizeof(wrapper);
  ty->tp_dealloc = _dtor;
  ty->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
  ty->tp_doc = "CLIF wrapper for ::nucleus::InMemoryFastaReader";
  ty->tp_methods = MethodsStaticAlloc;
  ty->tp_getset = Properties;
  ty->tp_init = Clif_PyType_Inconstructible;
  ty->tp_alloc = _new;
  ty->tp_new = PyType_GenericNew;
  ty->tp_free = _del;
  ty->tp_weaklistoffset = offsetof(wrapper, weakrefs);
  return ty;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  DCHECK(nitems == 0);
  wrapper* wobj = new wrapper;
  PyObject* self = reinterpret_cast<PyObject*>(wobj);
  return PyObject_Init(self, wrapper_Type);
}

static ::nucleus::InMemoryFastaReader* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, "as_nucleus_InMemoryFastaReader", nullptr);
  if (base == nullptr) {
    PyErr_Clear();
  } else {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, "::nucleus::InMemoryFastaReader");
      if (!PyErr_Occurred()) {
        ::nucleus::InMemoryFastaReader* c = static_cast<::nucleus::InMemoryFastaReader*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(wrapper_Type))) {
    if (!base) {
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::nucleus::InMemoryFastaReader*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type->tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}

}  // namespace pyInMemoryFastaReader

// Initialize module

bool Ready() {
  pyGenomeReferenceRecordIterable::wrapper_Type =
  pyGenomeReferenceRecordIterable::_build_heap_type();
  if (PyType_Ready(pyGenomeReferenceRecordIterable::wrapper_Type) < 0) return false;
  PyObject *modname = PyUnicode_FromString(ThisModuleName);
  if (modname == nullptr) return false;
  PyObject_SetAttrString((PyObject *) pyGenomeReferenceRecordIterable::wrapper_Type, "__module__", modname);
  Py_INCREF(pyGenomeReferenceRecordIterable::wrapper_Type);  // For PyModule_AddObject to steal.
  pyGenomeReference::wrapper_Type =
  pyGenomeReference::_build_heap_type();
  if (PyType_Ready(pyGenomeReference::wrapper_Type) < 0) return false;
  PyObject_SetAttrString((PyObject *) pyGenomeReference::wrapper_Type, "__module__", modname);
  Py_INCREF(pyGenomeReference::wrapper_Type);  // For PyModule_AddObject to steal.
  pyIndexedFastaReader::wrapper_Type =
  pyIndexedFastaReader::_build_heap_type();
  Py_INCREF(pyGenomeReference::wrapper_Type);
  pyIndexedFastaReader::wrapper_Type->tp_base = pyGenomeReference::wrapper_Type;
  if (PyType_Ready(pyIndexedFastaReader::wrapper_Type) < 0) return false;
  PyObject_SetAttrString((PyObject *) pyIndexedFastaReader::wrapper_Type, "__module__", modname);
  Py_INCREF(pyIndexedFastaReader::wrapper_Type);  // For PyModule_AddObject to steal.
  pyUnindexedFastaReader::wrapper_Type =
  pyUnindexedFastaReader::_build_heap_type();
  Py_INCREF(pyGenomeReference::wrapper_Type);
  pyUnindexedFastaReader::wrapper_Type->tp_base = pyGenomeReference::wrapper_Type;
  if (PyType_Ready(pyUnindexedFastaReader::wrapper_Type) < 0) return false;
  PyObject_SetAttrString((PyObject *) pyUnindexedFastaReader::wrapper_Type, "__module__", modname);
  Py_INCREF(pyUnindexedFastaReader::wrapper_Type);  // For PyModule_AddObject to steal.
  pyInMemoryFastaReader::wrapper_Type =
  pyInMemoryFastaReader::_build_heap_type();
  Py_INCREF(pyGenomeReference::wrapper_Type);
  pyInMemoryFastaReader::wrapper_Type->tp_base = pyGenomeReference::wrapper_Type;
  if (PyType_Ready(pyInMemoryFastaReader::wrapper_Type) < 0) return false;
  PyObject_SetAttrString((PyObject *) pyInMemoryFastaReader::wrapper_Type, "__module__", modname);
  Py_INCREF(pyInMemoryFastaReader::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  ThisModuleName,
  "CLIF-generated module for third_party/nucleus/io/python/reference.clif", // module doc
  -1,  // module keeps state in global variables
  nullptr,
  nullptr,  // m_slots a.k.a. m_reload
  nullptr,  // m_traverse
  ClearImportCache  // m_clear
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "GenomeReferenceRecordIterable", reinterpret_cast<PyObject*>(pyGenomeReferenceRecordIterable::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "GenomeReference", reinterpret_cast<PyObject*>(pyGenomeReference::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IndexedFastaReader", reinterpret_cast<PyObject*>(pyIndexedFastaReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "UnindexedFastaReader", reinterpret_cast<PyObject*>(pyUnindexedFastaReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "InMemoryFastaReader", reinterpret_cast<PyObject*>(pyInMemoryFastaReader::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace third__party_nucleus_io_python_reference_clifwrap

namespace nucleus {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// GenomeReference to/from ::nucleus::GenomeReference conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::GenomeReference** c) {
  CHECK(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::nucleus::GenomeReference* cpp = third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::nucleus::GenomeReference>* c) {
  CHECK(c != nullptr);
  ::nucleus::GenomeReference* cpp = third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::GenomeReference>* c) {
  CHECK(c != nullptr);
  ::nucleus::GenomeReference* cpp = third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert GenomeReference instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::nucleus::GenomeReference* c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::GenomeReference) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::GenomeReference>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::nucleus::GenomeReference> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::GenomeReference) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::GenomeReference>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::nucleus::GenomeReference> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::GenomeReference) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReference::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::GenomeReference>(std::move(c));
  return py;
}

// GenomeReferenceRecordIterable to/from ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>> conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>** c) {
  CHECK(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* cpp = third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>>* c) {
  CHECK(c != nullptr);
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* cpp = third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>>* c) {
  CHECK(c != nullptr);
  ::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* cpp = third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert GenomeReferenceRecordIterable instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>* c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyGenomeReferenceRecordIterable::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::Iterable<std::pair< ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>, ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>>>>(std::move(c));
  return py;
}

// InMemoryFastaReader to/from ::nucleus::InMemoryFastaReader conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::InMemoryFastaReader** c) {
  CHECK(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::nucleus::InMemoryFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::nucleus::InMemoryFastaReader>* c) {
  CHECK(c != nullptr);
  ::nucleus::InMemoryFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::InMemoryFastaReader>* c) {
  CHECK(c != nullptr);
  ::nucleus::InMemoryFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert InMemoryFastaReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::nucleus::InMemoryFastaReader* c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::InMemoryFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::InMemoryFastaReader>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::nucleus::InMemoryFastaReader> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::InMemoryFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::InMemoryFastaReader>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::nucleus::InMemoryFastaReader> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::InMemoryFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyInMemoryFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::InMemoryFastaReader>(std::move(c));
  return py;
}

// IndexedFastaReader to/from ::nucleus::IndexedFastaReader conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::IndexedFastaReader** c) {
  CHECK(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::nucleus::IndexedFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::nucleus::IndexedFastaReader>* c) {
  CHECK(c != nullptr);
  ::nucleus::IndexedFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::IndexedFastaReader>* c) {
  CHECK(c != nullptr);
  ::nucleus::IndexedFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IndexedFastaReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::nucleus::IndexedFastaReader* c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::IndexedFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::IndexedFastaReader>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::nucleus::IndexedFastaReader> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::IndexedFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::IndexedFastaReader>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::nucleus::IndexedFastaReader> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::IndexedFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyIndexedFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::IndexedFastaReader>(std::move(c));
  return py;
}

// UnindexedFastaReader to/from ::nucleus::UnindexedFastaReader conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::UnindexedFastaReader** c) {
  CHECK(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::nucleus::UnindexedFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::nucleus::UnindexedFastaReader>* c) {
  CHECK(c != nullptr);
  ::nucleus::UnindexedFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::UnindexedFastaReader>* c) {
  CHECK(c != nullptr);
  ::nucleus::UnindexedFastaReader* cpp = third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert UnindexedFastaReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::nucleus::UnindexedFastaReader* c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::UnindexedFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::UnindexedFastaReader>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::nucleus::UnindexedFastaReader> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::UnindexedFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::UnindexedFastaReader>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::nucleus::UnindexedFastaReader> c, py::PostConv unused) {
  CHECK(third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper_Type != nullptr) <<
    "---> Function Clif_PyObjFrom(::nucleus::UnindexedFastaReader) called before " <<
    third__party_nucleus_io_python_reference_clifwrap::ThisModuleName  <<
    " was imported from Python.";
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<third__party_nucleus_io_python_reference_clifwrap::pyUnindexedFastaReader::wrapper*>(py)->cpp = ::clif::Instance<::nucleus::UnindexedFastaReader>(std::move(c));
  return py;
}

}  // namespace nucleus
