//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: third_party/nucleus/util/python/utils.clif

#include <Python.h>
#include "absl/memory/memory.h"
#include "absl/types/optional.h"
#include "clif/python/types.h"
#include "third_party/nucleus/protos/range_pyclif.h"
#include "third_party/nucleus/protos/reads_pyclif.h"
#include "third_party/nucleus/util/proto_clif_converter.h"
#include "utils.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace third__party_nucleus_util_python_utils_clifwrap {

using namespace clif;

static const char* ThisModuleName = "third_party.nucleus.util.python.utils";

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

// read_end(read:ConstProtoPtr<Read>, use_cached_read_end:bool) -> int
static PyObject* wrapReadEndPython_as_read_end(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  const char* names[] = {
      "read",
      "use_cached_read_end",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_end", const_cast<char**>(names), &a[0], &a[1])) return nullptr;
  ::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_end", names[0], "::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read>", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_end", names[1], "bool", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  long long ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::ReadEndPython(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_range(read:ConstProtoPtr<Read>, range_pb:EmptyProtoPtr<Range>, use_cached_read_end:bool)
static PyObject* wrapReadRangePython_as_read_range(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  const char* names[] = {
      "read",
      "range_pb",
      "use_cached_read_end",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:read_range", const_cast<char**>(names), &a[0], &a[1], &a[2])) return nullptr;
  ::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_range", names[0], "::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read>", a[0]);
  ::nucleus::EmptyProtoPtr< ::nucleus::genomics::v1::Range> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_range", names[1], "::nucleus::EmptyProtoPtr< ::nucleus::genomics::v1::Range>", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_range", names[2], "bool", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ::nucleus::ReadRangePython(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_overlaps_region(read:ConstProtoPtr<Read>, range_pb:ConstProtoPtr<Range>, use_cached_read_end:bool) -> bool
static PyObject* wrapReadOverlapsRegionPython_as_read_overlaps_region(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  const char* names[] = {
      "read",
      "range_pb",
      "use_cached_read_end",
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:read_overlaps_region", const_cast<char**>(names), &a[0], &a[1], &a[2])) return nullptr;
  ::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_overlaps_region", names[0], "::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read>", a[0]);
  ::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Range> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_overlaps_region", names[1], "::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Range>", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_overlaps_region", names[2], "bool", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  std::string err_msg{"C++ exception"};
  try {
    ret0 = ::nucleus::ReadOverlapsRegionPython(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += std::string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Initialize module

static PyMethodDef MethodsStaticAlloc[] = {
  {"read_end", (PyCFunction)wrapReadEndPython_as_read_end, METH_VARARGS | METH_KEYWORDS, "read_end(read:ConstProtoPtr<Read>, use_cached_read_end:bool) -> int\n  Calls C++ function\n  long long ::nucleus::ReadEndPython(::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read>, bool)"},
  {"read_range", (PyCFunction)wrapReadRangePython_as_read_range, METH_VARARGS | METH_KEYWORDS, "read_range(read:ConstProtoPtr<Read>, range_pb:EmptyProtoPtr<Range>, use_cached_read_end:bool)\n  Calls C++ function\n  void ::nucleus::ReadRangePython(::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read>, ::nucleus::EmptyProtoPtr< ::nucleus::genomics::v1::Range>, bool)"},
  {"read_overlaps_region", (PyCFunction)wrapReadOverlapsRegionPython_as_read_overlaps_region, METH_VARARGS | METH_KEYWORDS, "read_overlaps_region(read:ConstProtoPtr<Read>, range_pb:ConstProtoPtr<Range>, use_cached_read_end:bool) -> bool\n  Calls C++ function\n  bool ::nucleus::ReadOverlapsRegionPython(::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Read>, ::nucleus::ConstProtoPtr<const ::nucleus::genomics::v1::Range>, bool)"},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  ThisModuleName,
  "CLIF-generated module for third_party/nucleus/util/python/utils.clif", // module doc
  -1,  // module keeps state in global variables
  MethodsStaticAlloc,
  nullptr,  // m_slots a.k.a. m_reload
  nullptr,  // m_traverse
  ClearImportCache  // m_clear
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  return module;
}

}  // namespace third__party_nucleus_util_python_utils_clifwrap
