//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: third_party/nucleus/protos/variants.proto

#include "clif/python/runtime.h"
#include "clif/python/types.h"
#include "third_party/nucleus/protos/variants_pyclif.h"

namespace nucleus { namespace genomics { namespace v1 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// Variant to/from ::nucleus::genomics::v1::Variant conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::Variant* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.Variant");
  if (!::clif::proto::TypeCheck(py, type, "", "Variant") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::Variant>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::Variant);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::Variant& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.Variant");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::Variant> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.Variant");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::Variant> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.Variant");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VariantCall to/from ::nucleus::genomics::v1::VariantCall conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VariantCall* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VariantCall");
  if (!::clif::proto::TypeCheck(py, type, "", "VariantCall") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VariantCall>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VariantCall);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VariantCall& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VariantCall");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VariantCall> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VariantCall> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfHeader to/from ::nucleus::genomics::v1::VcfHeader conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfHeader* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfHeader");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfHeader") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfHeader>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfHeader);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfHeader& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfHeader");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfHeader> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfHeader");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfHeader> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfHeader");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfFilterInfo to/from ::nucleus::genomics::v1::VcfFilterInfo conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfFilterInfo* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFilterInfo");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfFilterInfo") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfFilterInfo>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfFilterInfo);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfFilterInfo& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFilterInfo");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfFilterInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFilterInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfFilterInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFilterInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfInfo to/from ::nucleus::genomics::v1::VcfInfo conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfInfo* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfInfo");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfInfo") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfInfo>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfInfo);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfInfo& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfInfo");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfFormatInfo to/from ::nucleus::genomics::v1::VcfFormatInfo conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfFormatInfo* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFormatInfo");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfFormatInfo") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfFormatInfo>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfFormatInfo);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfFormatInfo& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFormatInfo");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfFormatInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFormatInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfFormatInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfFormatInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfStructuredExtra to/from ::nucleus::genomics::v1::VcfStructuredExtra conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfStructuredExtra* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfStructuredExtra");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfStructuredExtra") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfStructuredExtra>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfStructuredExtra);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfStructuredExtra& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfStructuredExtra");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfStructuredExtra> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfStructuredExtra");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfStructuredExtra> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfStructuredExtra");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfExtra to/from ::nucleus::genomics::v1::VcfExtra conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfExtra* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfExtra");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfExtra") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfExtra>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfExtra);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfExtra& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfExtra");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfExtra> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfExtra");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfExtra> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfExtra");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfReaderOptions to/from ::nucleus::genomics::v1::VcfReaderOptions conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfReaderOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfReaderOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfReaderOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfReaderOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfReaderOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfReaderOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfReaderOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfReaderOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfReaderOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfReaderOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfReaderOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VcfWriterOptions to/from ::nucleus::genomics::v1::VcfWriterOptions conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::VcfWriterOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfWriterOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "VcfWriterOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::VcfWriterOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::VcfWriterOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::VcfWriterOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfWriterOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::VcfWriterOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfWriterOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::VcfWriterOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.variants_pb2.VcfWriterOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

} } }  // namespace nucleus::genomics::v1
