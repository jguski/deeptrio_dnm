//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: third_party/nucleus/protos/reads.proto

#include "clif/python/runtime.h"
#include "clif/python/types.h"
#include "third_party/nucleus/protos/reads_pyclif.h"

namespace nucleus { namespace genomics { namespace v1 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// LinearAlignment to/from ::nucleus::genomics::v1::LinearAlignment conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::LinearAlignment* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.LinearAlignment");
  if (!::clif::proto::TypeCheck(py, type, "", "LinearAlignment") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::LinearAlignment>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::LinearAlignment);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::LinearAlignment& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.LinearAlignment");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::LinearAlignment> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.LinearAlignment");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::LinearAlignment> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.LinearAlignment");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// Read to/from ::nucleus::genomics::v1::Read conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::Read* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Read");
  if (!::clif::proto::TypeCheck(py, type, "", "Read") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::Read>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::Read);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::Read& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Read");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::Read> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Read");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::Read> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Read");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// SamHeader to/from ::nucleus::genomics::v1::SamHeader conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::SamHeader* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamHeader");
  if (!::clif::proto::TypeCheck(py, type, "", "SamHeader") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::SamHeader>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::SamHeader);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::SamHeader& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamHeader");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::SamHeader> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamHeader");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::SamHeader> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamHeader");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// ReadGroup to/from ::nucleus::genomics::v1::ReadGroup conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::ReadGroup* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadGroup");
  if (!::clif::proto::TypeCheck(py, type, "", "ReadGroup") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::ReadGroup>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::ReadGroup);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::ReadGroup& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadGroup");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::ReadGroup> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadGroup");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::ReadGroup> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadGroup");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// Program to/from ::nucleus::genomics::v1::Program conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::Program* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Program");
  if (!::clif::proto::TypeCheck(py, type, "", "Program") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::Program>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::Program);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::Program& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Program");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::Program> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Program");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::Program> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.Program");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// SamReaderOptions to/from ::nucleus::genomics::v1::SamReaderOptions conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::SamReaderOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamReaderOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "SamReaderOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::SamReaderOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::SamReaderOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::SamReaderOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamReaderOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::SamReaderOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamReaderOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::SamReaderOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.SamReaderOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// ReadRequirements to/from ::nucleus::genomics::v1::ReadRequirements conversion

bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::ReadRequirements* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadRequirements");
  if (!::clif::proto::TypeCheck(py, type, "", "ReadRequirements") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::nucleus::genomics::v1::ReadRequirements>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::nucleus::genomics::v1::ReadRequirements);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::nucleus::genomics::v1::ReadRequirements& c, py::PostConv) {
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadRequirements");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::nucleus::genomics::v1::ReadRequirements> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadRequirements");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::nucleus::genomics::v1::ReadRequirements> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("third_party.nucleus.protos.reads_pb2.ReadRequirements");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// SamHeader.SortingOrder to/from enum ::nucleus::genomics::v1::SamHeader::SortingOrder conversion
bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::SamHeader::SortingOrder* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::nucleus::genomics::v1::SamHeader::SortingOrder>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::nucleus::genomics::v1::SamHeader::SortingOrder c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// SamHeader.AlignmentGrouping to/from enum ::nucleus::genomics::v1::SamHeader::AlignmentGrouping conversion
bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::SamHeader::AlignmentGrouping* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::nucleus::genomics::v1::SamHeader::AlignmentGrouping>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::nucleus::genomics::v1::SamHeader::AlignmentGrouping c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// SamReaderOptions.AuxFieldHandling to/from enum ::nucleus::genomics::v1::SamReaderOptions::AuxFieldHandling conversion
bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::SamReaderOptions::AuxFieldHandling* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::nucleus::genomics::v1::SamReaderOptions::AuxFieldHandling>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::nucleus::genomics::v1::SamReaderOptions::AuxFieldHandling c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// ReadRequirements.MinBaseQualityMode to/from enum ::nucleus::genomics::v1::ReadRequirements::MinBaseQualityMode conversion
bool Clif_PyObjAs(PyObject* py, ::nucleus::genomics::v1::ReadRequirements::MinBaseQualityMode* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::nucleus::genomics::v1::ReadRequirements::MinBaseQualityMode>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::nucleus::genomics::v1::ReadRequirements::MinBaseQualityMode c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

} } }  // namespace nucleus::genomics::v1
