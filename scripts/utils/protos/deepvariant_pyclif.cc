//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: deepvariant/protos/deepvariant.proto

#include "clif/python/runtime.h"
#include "clif/python/types.h"
#include "deepvariant/protos/deepvariant_pyclif.h"

namespace learning { namespace genomics { namespace deepvariant {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// Allele to/from ::learning::genomics::deepvariant::Allele conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::Allele* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.Allele");
  if (!::clif::proto::TypeCheck(py, type, "", "Allele") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::Allele>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::Allele);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::Allele& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.Allele");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::Allele> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.Allele");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::Allele> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.Allele");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// AlleleCount to/from ::learning::genomics::deepvariant::AlleleCount conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::AlleleCount* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  if (!::clif::proto::TypeCheck(py, type, "", "AlleleCount") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::AlleleCount>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::AlleleCount);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::AlleleCount& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::AlleleCount> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::AlleleCount> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// AlleleCount.Alleles to/from ::learning::genomics::deepvariant::AlleleCount::Alleles conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::AlleleCount::Alleles* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  if (!::clif::proto::TypeCheck(py, type, "Alleles", "AlleleCount.Alleles") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::AlleleCount::Alleles>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::AlleleCount::Alleles);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::AlleleCount::Alleles& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  return ::clif::proto::PyProtoFrom(&c, type, "Alleles");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::AlleleCount::Alleles> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  return ::clif::proto::PyProtoFrom(c.get(), type, "Alleles");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::AlleleCount::Alleles> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCount");
  return ::clif::proto::PyProtoFrom(c.get(), type, "Alleles");
}

// AlleleCountSummary to/from ::learning::genomics::deepvariant::AlleleCountSummary conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::AlleleCountSummary* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCountSummary");
  if (!::clif::proto::TypeCheck(py, type, "", "AlleleCountSummary") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::AlleleCountSummary>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::AlleleCountSummary);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::AlleleCountSummary& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCountSummary");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::AlleleCountSummary> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCountSummary");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::AlleleCountSummary> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCountSummary");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// DeepVariantCall to/from ::learning::genomics::deepvariant::DeepVariantCall conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantCall* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  if (!::clif::proto::TypeCheck(py, type, "", "DeepVariantCall") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantCall>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantCall);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantCall& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantCall> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantCall> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// DeepVariantCall.SupportingReads to/from ::learning::genomics::deepvariant::DeepVariantCall::SupportingReads conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantCall::SupportingReads* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  if (!::clif::proto::TypeCheck(py, type, "SupportingReads", "DeepVariantCall.SupportingReads") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantCall::SupportingReads>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantCall::SupportingReads);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantCall::SupportingReads& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(&c, type, "SupportingReads");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantCall::SupportingReads> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "SupportingReads");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantCall::SupportingReads> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "SupportingReads");
}

// DeepVariantCall.ReadSupport to/from ::learning::genomics::deepvariant::DeepVariantCall::ReadSupport conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantCall::ReadSupport* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  if (!::clif::proto::TypeCheck(py, type, "ReadSupport", "DeepVariantCall.ReadSupport") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantCall::ReadSupport>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantCall::ReadSupport);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantCall::ReadSupport& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(&c, type, "ReadSupport");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantCall::ReadSupport> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "ReadSupport");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantCall::ReadSupport> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "ReadSupport");
}

// DeepVariantCall.SupportingReadsExt to/from ::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  if (!::clif::proto::TypeCheck(py, type, "SupportingReadsExt", "DeepVariantCall.SupportingReadsExt") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(&c, type, "SupportingReadsExt");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "SupportingReadsExt");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantCall::SupportingReadsExt> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantCall");
  return ::clif::proto::PyProtoFrom(c.get(), type, "SupportingReadsExt");
}

// AlleleCounterOptions to/from ::learning::genomics::deepvariant::AlleleCounterOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::AlleleCounterOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCounterOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "AlleleCounterOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::AlleleCounterOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::AlleleCounterOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::AlleleCounterOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCounterOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::AlleleCounterOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCounterOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::AlleleCounterOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.AlleleCounterOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// CallVariantsOutput to/from ::learning::genomics::deepvariant::CallVariantsOutput conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::CallVariantsOutput* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  if (!::clif::proto::TypeCheck(py, type, "", "CallVariantsOutput") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::CallVariantsOutput>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::CallVariantsOutput);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::CallVariantsOutput& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::CallVariantsOutput> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::CallVariantsOutput> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// CallVariantsOutput.AltAlleleIndices to/from ::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  if (!::clif::proto::TypeCheck(py, type, "AltAlleleIndices", "CallVariantsOutput.AltAlleleIndices") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(&c, type, "AltAlleleIndices");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(c.get(), type, "AltAlleleIndices");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::CallVariantsOutput::AltAlleleIndices> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(c.get(), type, "AltAlleleIndices");
}

// CallVariantsOutput.DebugInfo to/from ::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  if (!::clif::proto::TypeCheck(py, type, "DebugInfo", "CallVariantsOutput.DebugInfo") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(&c, type, "DebugInfo");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(c.get(), type, "DebugInfo");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::CallVariantsOutput::DebugInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.CallVariantsOutput");
  return ::clif::proto::PyProtoFrom(c.get(), type, "DebugInfo");
}

// VariantCallerOptions to/from ::learning::genomics::deepvariant::VariantCallerOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::VariantCallerOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantCallerOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "VariantCallerOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::VariantCallerOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::VariantCallerOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::VariantCallerOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantCallerOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::VariantCallerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantCallerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::VariantCallerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantCallerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// VariantLabelerOptions to/from ::learning::genomics::deepvariant::VariantLabelerOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::VariantLabelerOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantLabelerOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "VariantLabelerOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::VariantLabelerOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::VariantLabelerOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::VariantLabelerOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantLabelerOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::VariantLabelerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantLabelerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::VariantLabelerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.VariantLabelerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// PileupImageOptions to/from ::learning::genomics::deepvariant::PileupImageOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::PileupImageOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.PileupImageOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "PileupImageOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::PileupImageOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::PileupImageOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::PileupImageOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.PileupImageOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::PileupImageOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.PileupImageOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::PileupImageOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.PileupImageOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// SampleOptions to/from ::learning::genomics::deepvariant::SampleOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::SampleOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.SampleOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "SampleOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::SampleOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::SampleOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::SampleOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.SampleOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::SampleOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.SampleOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::SampleOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.SampleOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// MakeExamplesOptions to/from ::learning::genomics::deepvariant::MakeExamplesOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::MakeExamplesOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "MakeExamplesOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::MakeExamplesOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::MakeExamplesOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::MakeExamplesOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::MakeExamplesOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::MakeExamplesOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// DeepVariantDatasetConfig to/from ::learning::genomics::deepvariant::DeepVariantDatasetConfig conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantDatasetConfig* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantDatasetConfig");
  if (!::clif::proto::TypeCheck(py, type, "", "DeepVariantDatasetConfig") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantDatasetConfig>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantDatasetConfig);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantDatasetConfig& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantDatasetConfig");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantDatasetConfig> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantDatasetConfig");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantDatasetConfig> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantDatasetConfig");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// DeepVariantInputDatasets to/from ::learning::genomics::deepvariant::DeepVariantInputDatasets conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantInputDatasets* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  if (!::clif::proto::TypeCheck(py, type, "", "DeepVariantInputDatasets") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantInputDatasets>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantInputDatasets);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantInputDatasets& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantInputDatasets> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantInputDatasets> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// DeepVariantInputDatasets.Dataset to/from ::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  if (!::clif::proto::TypeCheck(py, type, "Dataset", "DeepVariantInputDatasets.Dataset") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  return ::clif::proto::PyProtoFrom(&c, type, "Dataset");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  return ::clif::proto::PyProtoFrom(c.get(), type, "Dataset");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantInputDatasets::Dataset> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasets");
  return ::clif::proto::PyProtoFrom(c.get(), type, "Dataset");
}

// DeepVariantInputDatasetsGroup to/from ::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasetsGroup");
  if (!::clif::proto::TypeCheck(py, type, "", "DeepVariantInputDatasetsGroup") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasetsGroup");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasetsGroup");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeepVariantInputDatasetsGroup> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.DeepVariantInputDatasetsGroup");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// LabelingMetrics to/from ::learning::genomics::deepvariant::LabelingMetrics conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::LabelingMetrics* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.LabelingMetrics");
  if (!::clif::proto::TypeCheck(py, type, "", "LabelingMetrics") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::LabelingMetrics>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::LabelingMetrics);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::LabelingMetrics& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.LabelingMetrics");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::LabelingMetrics> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.LabelingMetrics");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::LabelingMetrics> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.LabelingMetrics");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// MakeExamplesStats to/from ::learning::genomics::deepvariant::MakeExamplesStats conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::MakeExamplesStats* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesStats");
  if (!::clif::proto::TypeCheck(py, type, "", "MakeExamplesStats") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::MakeExamplesStats>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::MakeExamplesStats);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::MakeExamplesStats& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesStats");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::MakeExamplesStats> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesStats");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::MakeExamplesStats> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesStats");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// MakeExamplesRunInfo to/from ::learning::genomics::deepvariant::MakeExamplesRunInfo conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::MakeExamplesRunInfo* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesRunInfo");
  if (!::clif::proto::TypeCheck(py, type, "", "MakeExamplesRunInfo") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::MakeExamplesRunInfo>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::MakeExamplesRunInfo);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::MakeExamplesRunInfo& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesRunInfo");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::MakeExamplesRunInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesRunInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::MakeExamplesRunInfo> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.deepvariant_pb2.MakeExamplesRunInfo");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// PileupImageOptions.MultiAllelicMode to/from enum ::learning::genomics::deepvariant::PileupImageOptions::MultiAllelicMode conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::PileupImageOptions::MultiAllelicMode* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::PileupImageOptions::MultiAllelicMode>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::PileupImageOptions::MultiAllelicMode c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// PileupImageOptions.SequencingType to/from enum ::learning::genomics::deepvariant::PileupImageOptions::SequencingType conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::PileupImageOptions::SequencingType* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::PileupImageOptions::SequencingType>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::PileupImageOptions::SequencingType c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// MakeExamplesOptions.Mode to/from enum ::learning::genomics::deepvariant::MakeExamplesOptions::Mode conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::MakeExamplesOptions::Mode* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::MakeExamplesOptions::Mode>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::MakeExamplesOptions::Mode c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// MakeExamplesOptions.LabelerAlgorithm to/from enum ::learning::genomics::deepvariant::MakeExamplesOptions::LabelerAlgorithm conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::MakeExamplesOptions::LabelerAlgorithm* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::MakeExamplesOptions::LabelerAlgorithm>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::MakeExamplesOptions::LabelerAlgorithm c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// MakeExamplesOptions.VariantCaller to/from enum ::learning::genomics::deepvariant::MakeExamplesOptions::VariantCaller conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::MakeExamplesOptions::VariantCaller* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::MakeExamplesOptions::VariantCaller>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::MakeExamplesOptions::VariantCaller c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

// AlleleType to/from enum ::learning::genomics::deepvariant::AlleleType conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::AlleleType* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::AlleleType>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::AlleleType c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

} } }  // namespace learning::genomics::deepvariant
