//////////////////////////////////////////////////////////////////////
// This file was automatically generated by PyCLIF.
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: deepvariant/protos/realigner.proto

#include "clif/python/runtime.h"
#include "clif/python/types.h"
#include "deepvariant/protos/realigner_pyclif.h"

namespace learning { namespace genomics { namespace deepvariant {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CandidateHaplotypes to/from ::learning::genomics::deepvariant::CandidateHaplotypes conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::CandidateHaplotypes* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.CandidateHaplotypes");
  if (!::clif::proto::TypeCheck(py, type, "", "CandidateHaplotypes") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::CandidateHaplotypes>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::CandidateHaplotypes);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::CandidateHaplotypes& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.CandidateHaplotypes");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::CandidateHaplotypes> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.CandidateHaplotypes");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::CandidateHaplotypes> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.CandidateHaplotypes");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// WindowSelectorModel to/from ::learning::genomics::deepvariant::WindowSelectorModel conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::WindowSelectorModel* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  if (!::clif::proto::TypeCheck(py, type, "", "WindowSelectorModel") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::WindowSelectorModel>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::WindowSelectorModel);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::WindowSelectorModel& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::WindowSelectorModel> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::WindowSelectorModel> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// WindowSelectorModel.VariantReadsThresholdModel to/from ::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  if (!::clif::proto::TypeCheck(py, type, "VariantReadsThresholdModel", "WindowSelectorModel.VariantReadsThresholdModel") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(&c, type, "VariantReadsThresholdModel");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(c.get(), type, "VariantReadsThresholdModel");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::WindowSelectorModel::VariantReadsThresholdModel> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(c.get(), type, "VariantReadsThresholdModel");
}

// WindowSelectorModel.AlleleCountLinearModel to/from ::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  if (!::clif::proto::TypeCheck(py, type, "AlleleCountLinearModel", "WindowSelectorModel.AlleleCountLinearModel") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(&c, type, "AlleleCountLinearModel");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(c.get(), type, "AlleleCountLinearModel");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::WindowSelectorModel::AlleleCountLinearModel> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorModel");
  return ::clif::proto::PyProtoFrom(c.get(), type, "AlleleCountLinearModel");
}

// WindowSelectorOptions to/from ::learning::genomics::deepvariant::WindowSelectorOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::WindowSelectorOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "WindowSelectorOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::WindowSelectorOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::WindowSelectorOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::WindowSelectorOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::WindowSelectorOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::WindowSelectorOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.WindowSelectorOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// DeBruijnGraphOptions to/from ::learning::genomics::deepvariant::DeBruijnGraphOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::DeBruijnGraphOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.DeBruijnGraphOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "DeBruijnGraphOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::DeBruijnGraphOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::DeBruijnGraphOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::DeBruijnGraphOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.DeBruijnGraphOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::DeBruijnGraphOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.DeBruijnGraphOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::DeBruijnGraphOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.DeBruijnGraphOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// AlignerOptions to/from ::learning::genomics::deepvariant::AlignerOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::AlignerOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.AlignerOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "AlignerOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::AlignerOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::AlignerOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::AlignerOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.AlignerOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::AlignerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.AlignerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::AlignerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.AlignerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// Diagnostics to/from ::learning::genomics::deepvariant::Diagnostics conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::Diagnostics* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.Diagnostics");
  if (!::clif::proto::TypeCheck(py, type, "", "Diagnostics") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::Diagnostics>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::Diagnostics);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::Diagnostics& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.Diagnostics");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::Diagnostics> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.Diagnostics");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::Diagnostics> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.Diagnostics");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// RealignerOptions to/from ::learning::genomics::deepvariant::RealignerOptions conversion

bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::RealignerOptions* c) {
  CHECK(c != nullptr);
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.RealignerOptions");
  if (!::clif::proto::TypeCheck(py, type, "", "RealignerOptions") ) {
    return ::clif::proto::InGeneratedPool(py, c);
  }
  if (const proto2::Message* cpb = ::clif::proto::GetCProto(py)) {
    c->CopyFrom(*cpb);
    return true;
  }
  PyObject* ser = ::clif::proto::Serialize(py);
  if (ser == nullptr) return false;
  bool ok = c->ParsePartialFromArray(PyBytes_AS_STRING(ser), static_cast<int>(PyBytes_GET_SIZE(ser)));
  Py_DECREF(ser);
  if (!ok) PyErr_SetString(PyExc_ValueError, "Serialized bytes can't be parsed into C++ proto");
  return ok;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::learning::genomics::deepvariant::RealignerOptions>* c) {
  CHECK(c != nullptr);
  if (!*c) c->reset(new ::learning::genomics::deepvariant::RealignerOptions);
  return Clif_PyObjAs(py, c->get());
}

PyObject* Clif_PyObjFrom(const ::learning::genomics::deepvariant::RealignerOptions& c, py::PostConv) {
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.RealignerOptions");
  return ::clif::proto::PyProtoFrom(&c, type, "");
}

PyObject* Clif_PyObjFrom(std::unique_ptr<const ::learning::genomics::deepvariant::RealignerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.RealignerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

PyObject* Clif_PyObjFrom(std::shared_ptr<const ::learning::genomics::deepvariant::RealignerOptions> c, py::PostConv) {
  if (!c) Py_RETURN_NONE;
  PyObject* type = ImportFQName("deepvariant.protos.realigner_pb2.RealignerOptions");
  return ::clif::proto::PyProtoFrom(c.get(), type, "");
}

// WindowSelectorModel.ModelType to/from enum ::learning::genomics::deepvariant::WindowSelectorModel::ModelType conversion
bool Clif_PyObjAs(PyObject* py, ::learning::genomics::deepvariant::WindowSelectorModel::ModelType* c) {
  CHECK(c != nullptr);
  int v;
  if (!Clif_PyObjAs(py, &v)) return false;
  *c = static_cast<::learning::genomics::deepvariant::WindowSelectorModel::ModelType>(v);
  return true;
}
PyObject* Clif_PyObjFrom(::learning::genomics::deepvariant::WindowSelectorModel::ModelType c, py::PostConv pc) {
  return Clif_PyObjFrom(static_cast<int>(c), pc);
}

} } }  // namespace learning::genomics::deepvariant
